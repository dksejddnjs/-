**0521 스프링 **

 스프링과 스프링 부트의 차이점:
   
스프링을 더 쉽게 사용할 수 있도록 구성 정보와 설정을 제공하는 것이 스프링 부트이다 

JAVA Spring:

자바를 기반으로 만들어진 애플리케이션 프레임워크를 의미한다. 프레임워크란 뼈대나 근간을 이루는 코드들의 묶음을 의미한다. 
개발에 필요한 구조를 이미 코드로 만들어 놓았기 때문에 필요한 부분은 조립하는 형태로 개발이 가능하고, 이러한 장점으로 프레임워크를 사용한 프로젝트는 일정한 품질을 보장하며 개발시간을 단축시킬 수 있다. 
자바 스프링은 경량 프레임워크이며 기존의 복잡한 구동환경을 벗어나 특정 기능 위주로 간단한 jar파일을 이용하여 개발을 가능하게 구성된 프레임워크 이다.

---------------------------

JAVA Spring의 주요 특징

- POJO(Plain Old Java Object) 기반의 구성
스프링은 객체간의 관계를 구성할 수 있는 특징을 가지고 있다. 일반적인 JAVA코드를 이용하여 객체를 구성하는 방식을 그대로 사용할 수 있다는 것이다. 따라서 개발자가 가장 일반적인 형태로 코드를 작성하고 실행 가능하여 유연하게 작업할 수 있다고 한다.

- 의존성 주입을 통한 관계 구성
  
의존성 주입이란 어떠한 객체가 필요한 객체를 외부에서 밀어넣는 방식을 말한다. 스프링에서 ApplicationContext라는 존재가 이러한 역할을 수행한다.  스프링에서 ApplicationContext가 관리하는 객체를 빈(Bean)이라고 부르며 빈과 빈사이의 의존관계를 처리하는 방식으로 XML설정, @어노테이션설정 등을 이용한다.

---------------------------

@어노태이션 종류 중 4가지

@Configuration: 이 어노테이션이 있는 클래스는 빈 설정을 담당하는 클래스가 된다. 이 클래스 안에서 @Bean 어노테이션이 동봉된 메소드를 선언하면, 그 메소드를 통해 스프링 빈을 정의하고 생명주기를 설정하게 된다.

@Autowired: 정말 자주 쓰는거 같다. 뭘지 궁금했는데 찾아보니 필드, 메소드, 생성자에다가 넣을 수 있고 스프링 빈을 가져오는 가장 기본적인 방법이라고 한다.

@Value:  사진 전송 구현할 때 사용하였는데 생성자, setter 따위의 메소드, 필드 등에다가 스프링에서 설정한 값을 주입할 수 있다. 주로application.properties 및 스프링이나 자바 property 값을 가져올 때 쓴다. 

@CrossOrigin: CORS 보안상의 문제로 브라우저에서 리소스를 현재 origin에서 다른 곳으로의 AJAX요청을 방지하는 것이다.

------------------------------------

CORS(Cross-Origin Resource Sharing):

CORS는 영어 그대로 교차 출처를 공유할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다. 서로 다른 출처를 가진 Application이 서로의 Resource 에 접근할 수 있도록 해준다.

------------------------------------

Origin:

기본적으로 프로토콜, 호스트, 포트 를 통틀어서 Origin(출처) 라고 한다. 
즉 서로 같은 출처는 이 셋이 동일한 출처를 말하고, 여기서 하나라도 다르다면 Cross Origin, 즉 교차출처가 되는 것이다.
* http://localhost:8080 : Spring Boot
* http://localhost:3000 : React
보안상의 이유로, 브라우저는 스크립트에서 시작한 Cross Origin HTTP Request를 제한한다. 즉, SOP(Same Origin Policy)를 따른다.
React와 Spring Boot의 port 가 서로 다르기 때문에 cors정책 위반 에러가 나왔던 것이다. 이건 따로 코드 추가를 하여 수정할 수 있다.

-------------------------------------------------------------------------------------------------------------

**240522 스프링**

AOP (Aspect-Oriented-Programming)지원:

AOP방식은 관점 지향 프로그래밍이다. 이는 횡단 관심사(반드시 처리가 필요한 부분)을 모듈로 분리하는 프로그래밍 패러다임이다. 이를 통해 개발자는 핵심 비지니스 로직에 집중하여 코드를 개발할 수 있고, 각 프로젝트마다 다른 관심사를 적용할때 코드 수정을 최소화할 수 있으며 원하는 관심사의 유지보수가 수월한 코드를 구성할 수 있다고 한다.

- 중심적 관심사: 실현해야 할 기능을 나타내는 프로그램
- 횡단적 관심사: 본질적인 기능은 아니지만 품질이나 유지보수 등의 관점에서 반드시 필요한 기능을 나타내는 프로그램
  
-------------------------------------------------------------------------------------
AOP 고유 용어

어드바이스 (Advice): 횡단적 관심사의 구현(메서드), 로그 출력 및 트랜잭션 제어 등 이다.

애스펙트 (Aspect) : 어드바이스를 정리한 것(클래스)이다.

조인포인트 (JoinPoint) : 어드바이스를 중심적인 관심사에 적용하는 타이밍, 메서드(생성자) 실행 전, 메서드(생성자) 실행 후 등 실행되는 타이밍이다.

포인트컷 (Ponitcut) : 어드바이스를 삽입할 수 있는 위치, 예를 들어, 메서드 이름이 get으로 시작할 때만 처리하는 조건을 정의할 수 있다.

인터셉터 (Interceptor): 처리의 제어를 인터셉트하기 위한 구조 또는 프로그램이다. 스프링 프레임워크에서는 인터셉트라는 매커니즘으로 어드바이스를 중심 관심사에 추가한 것처럼 보이게 한다.

타깃 (Target): 어드바이스가 도입되는 대상을 말한다.

-----------------------------------------
어드바이스 종류

- Before Advice : 중심적 관심사가 실행되기 이전에 횡단적 관심사를 실행 => @Before

- After Returning Advice : 중심적 관심사가 정상적으로 종료된 후에 횡단적 관심사를 실행 => @AfterReturning

- After Throwing Advice : 중심적 관심사로부터 예외가 던져진 후로 횡단적 관심사를 실행 => @AfterTrowing

- After Advice : 중심적 관심사의 실행 후에 횡단적 관심사를 실핼 (정상 종료나 예외 종료 등의 결과와 상관없이 실행) => @After

- Around Advice : 중앙적 관심사 호출 전후에 횡단적 관심사를 실행 => @Around

---------------------------------------------------------------

레이어별로 사용할 인스턴스 생성 어노테이션          도메인 주도 설계의 라이어

- 애플리케이션 레이어 (Application Layer) : 애플리케이션 레이어는 클라이언트와의 데이터 입출력을 제어하는 레이어이다.
  
- 도메인 레이어 (Domain Layer) : 도메인 레이어는 애플리케이션의 중심이 되는 레이어로서 업무 처리를 수행하는 레이어이다.

- 인프라스트럭처 레이어 (Intrastructure Layer) : 인프라스트럭처 레이어는 데이터베이스에 대한 데이터 영속성 등을 담당하는 레이어이다.
  
=> 인스턴스 생성 어노테이션은 레이어별로 구분할 수 있다.
@Controller : 애플리케이션 레이어의 컨트롤러에 부여

@Service : 도메인 레이어의 업무 처리에 부여

@Repository : 인프라 레이어의 데이터베이스 엑세스 처리에 부여

@Component : @Controller, @Service, @Repository의 용도 이외의 인스턴스 생성 대상 클래스에 부여

---------------------------------------------
**0523 스프링 CORS**

다시 기억하는 부분

CORS(Cross-Origin Resource Sharing):

CORS는 영어 그대로 교차 출처를 공유할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다. 서로 다른 출처를 가진 Application이 서로의 Resource 에 접근할 수 있도록 해준다.


Origin:

기본적으로 프로토콜, 호스트, 포트 를 통틀어서 Origin(출처) 라고 한다. 즉 서로 같은 출처는 이 셋이 동일한 출처를 말하고, 여기서 하나라도 다르다면 Cross Origin, 즉 교차출처가 되는 것이다.

---------------------------------------------

동일 출저 정책 (Same-Origin Policy)

SOP 정책은 단어 그대로 동일한 출처에 대한 정책을 말한다. 그리고 SOP 정책은 동일한 출처에서만 리소스를 공유할 수 있다 라는 것을 가지고 있다. 

Server A: A_image. png 

Server B: B_image. png

www.serverA.com에서 A_image. png는 가져올 수 있지만 B_image. png는 가져올 수 없다.

---------------------------------------------------------------------
동일 출처 정책이 필요한 이유

동일 출처가 아닌 경우 접근을 차단하는 이유는 출처가 다른 두 어플리케이션이 자유로이 소통할 수 있는 환경은 꽤 위험한 환경이다. 만약 제약이 없다면, 해커가 CSRF나 XXS 등의 방법을 이용하여 우리가 만든 어플리케이션에서 해커가 심어놓은 코드가 실행되어 개인 정보를 가로챌 수 있다.

-----------------------------------
출처 비교와 차단

이것은 브라우저에서 한다. 출처를 비교하는 로직은 서버에 구현된 스펙이 아닌 브라우저에 구현된 스펙에서 진행한다.

--------------------------------------------------------------------------------------

**0524 스프링 어노테이션 (지금까지 사용했던 어노테이션의 기능)**

### **Lombok 어노테이션**

**- @Getter**: 클래스의 모든 필드에 대한 getter 메서드를 자동으로 생성. 이를 통해 코드를 간결하게 유지할 수 있다.

**- @Builder**: 빌더 패턴을 적용하여 객체를 생성할 수 있게 한다. 이 패턴은 특히 불변 객체를 만들 때 유용하다. 예를 들어, 필드가 많은 경우나 선택적 필드가 있는 경우에 객체 생성이 더 간편해진다.

**- @AllArgsConstructor**: 모든 필드를 인수로 받는 생성자를 자동으로 생성한다. 예를 들어, user(id, username, userpwd)와 같은 형식으로 객체를 생성할 수 있게 한다.

**- @NoArgsConstructor**: 인수가 없는 기본 생성자를 자동으로 생성한다. 이는 프레임워크나 라이브러리가 객체를 리플렉션을 통해 생성해야 할 때 필요하다.

**- @RequiredArgsConstructor**: Lombok을 사용하여 final 필드나 @not null이 붙은 필드에 대한 생성자를 자동으로 생성한다. 주로 의존성 주입을 간편하게 하기 위해 사용된다.

**- @Log4j2**: Lombok을 사용하여 Log4j2 로거를 자동으로 생성. 이를 통해 클래스에서 로그를 쉽게 기록할 수 있다.

**- @Slf4j**: Lombok을 사용하여 SLF4J 로거를 자동으로 생성. 이를 통해 로그를 간편하게 기록할 수 있습니다.

### **JPA 어노테이션**

**- @Entity**: 이 클래스가 JPA 엔티티임을 명시한다. JPA는 자바 객체를 데이터베이스 테이블에 매핑하기 위한 API이다.

### **Jackson 어노테이션**

**- @JsonIgnoreProperties:** JSON 직렬화 시 특정 속성을 무시하도록 설정한다.

### **Spring WebSocket 관련 어노테이션**

**- @EnableWebSocket**: Spring WebSocket 지원을 활성화한다. WebSocket 핸들러를 등록하고 설정하기 위해 사용된다.

### **Spring Configuration 관련 어노테이션**

**- @Configuration**: 이 어노테이션은 클래스가 하나 이상의 @Bean 메서드를 포함하고 있음을 나타내며, Spring 애플리케이션 컨텍스트에서 Bean 정의를 구성합니다.

### **Spring MVC 관련 어노테이션**

**- @Controller**: 이 어노테이션은 해당 클래스가 Spring MVC 컨트롤러임을 나타낸다. 주로 HTTP 요청을 처리하고 뷰를 반환하는 메서드를 포함한다.

**- @RestController**: 이 어노테이션은 @Controller와  ****@ResponseBody를 결합한 것이다. 주로 JSON/XML 형식의 데이터를 반환하는 RESTful 웹 서비스 컨트롤러를 정의한다.

**- @CrossOrigin**: 이 어노테이션은 특정 클래스나 메서드가 다른 도메인에서 오는 HTTP 요청을 허용하도록 설정한다. CORS(Cross-Origin Resource Sharing)를 허용하기 위해 사용된다.

--------------------------------------------------------------------------------------------------
**0527 Spring Security**

Spring Security 
Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크이다. Spring Security는 인증과 권한에 대한 부분을 Filter 흐름에 따라 처리한다.
Filter는 Dispatcher Servlet으로 가기 전 적용되므로 가장 먼저 URL 요청을 받지만, Interceptor는 Dispatcher와 Controller 사이에 위치한다는 점에서 적용 시기의 차이가 있다.


장점:

Spring Security는 보안과 관련해서 체계적으로 많은 옵션을 제공해주기 때문에 일일이 보안관련 로직을 작성하지 않다도 된다는 장점이 있다.

-------------------------------------------------------------
Filter:

디스패처 서블릿(Dispatcher Servlet)에 요청이 전달되기 전/후에 URL 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공

--------------------
Dispatcher Servlet:

Dispatch의 의미는 급파하다, 파견 등의 의미로, 해석해보면 받은 요청을 어딘가로 빠르게 보내는 서블릿 이라는 뜻이다. 또한 프론트 컨트롤러라고 불리기도 한다.

-----------------------------------
Interceptor:

Spring이 제공하는 기술로써, 디스패치 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공

-------------------------------------------------------------------------------------------------------------------------

다시 기억하는 부분

AOP(Asepct Oriented Programming):

관점 지향 프로그래밍으로 관점 지향은 쉽게 말해 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다.
모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 의미한다.

------------------------------------------------------
인터셉터(Interceptor)와 AOP

인터셉터 대신에 컨트롤러에 적용할 부가기능을 어드바이스로 만들어 AOP를 적용할 수 있다. 하지만 다음의 이유들로 컨트롤러의 호출 과정에 적용되는 부가기능들은 인터셉터를 사용하는 편이 낫다.

1. 컨트롤러는 타입과 실행 메소드가 모두 제각각이라는 포인트컷(적용할 메소드 선별)의 작성이 어렵다.
   
2. 컨트롤러는 파라미터나 리턴 값이 일정하다.
   
3. AOP에서는 HttpServletRequest/ Response를 객체로 얻기 어렵지만 인터셉터에서는 파라미터로 넘어온다.
   
--------------------------------------------------------------------------------------
필터(Filter)와 인터셉터(Interceptor) 차이

**필터(Filter)**    

관리되는 컨테이너: 서블릿 컨테이너

스프링의 예외처리 여부: X

Request/ Response 객체 조작 가능 여부: O



**인터셉터(Interceptor)**

관리되는 컨테이너: 스프링 컨테이너

스프링의 예외처리 여부: O

Request/ Response 객체 조작 가능 여부: X


용도

필터(Filter)

- 공통된 보안 및 인증/ 인가 관련 작업

- 모든 요청에 대한 로깅 또는 감사

- 이미지/ 데이터 압축 및 문자열 인코딩

- Spring과 분리되어야 하는 기능

------------------------------
인터셉터(Interceptor)

- 세부적인 보안 및 인증/ 인가 공통 작업

- API 호출에 대한 로깅 또는 감사

- Controller로 넘겨주는 정보(데이터)의 가공
--------------------------------------------------------------------------------------

**0528 스프링**

@EnableRedisHttpSession

- 스프링 세션 프로젝트에서 제공하는 어노테이션

- 스프링 애플리케이션이 Redis가 지원하는 분산 세션을 사용할 수 있게 해준다.

- 애플리케이션 메모리 대신 Redis 메모리를 사용하게 되므로 애플리케이션의 수평적 확장에 유용하고 모든 인스턴스에서 세션 데이터가 일관되게 유지된다.

--------------------------------------------------------------------------
MVC 모델

프로그램의 처리 역할을 나누어서 프로그램을 작성하는 방법으로 웹 시스템 개발에 자주 사용된다. 역할은 모델(Model: M), 뷰(View: V), 컨트롤러(Controller: C) 세 종류로 분류한다.

--------------------------------------------------------------------------
모델(Model: M)

모델은 시스템에서 비즈니스 로직을 담당한다. 비즈니스 로직은 시스템의 코어 부분 혹은 시스템의 목적을 처리하는 부분 등의 뜻을 가지고 있다. 

--------------------------------------------------------------------------
뷰(View: V)

사용자 입력과 결과 출력 등 시스템에서 표현 부분을 담당하며 웹 애플리케이션에서는 주로 화면을 담당한다.

--------------------------------------------------------------------------
컨트롤러(Controller: C)

컨트롤러는 서비스 처리를 담당하는 모델과 화면 표시를 담당하는 뷰를 제어하는 역할을 한다. 사용자가 입력한 내용을 뷰에서 받고, 받은 데이터를 기준으로 모델에 내용을 전달한다. 또 모델에서 받은 데이터를 뷰에 전달해서 화면에 표시하는 역할을 한다.

--------------------------------------------------------------------------
MVC 모델의 이점
- 역할 분담을 통해 효율적인 개발 가능

- 개발하는 엔지니어의 분업화가 용이
  
- 설계 변경에 유연하게 대응 가능

--------------------------------------------------------------------------
스프링 MVC 구성 요소

- Dispatcher Servlet(Front Controller): 모든 요청을 수신하는 프런트 컨트롤러

- Model: 컨트롤러에서 뷰에 넘겨주는 표시용 데이터 등을 저장하는 객체

- 컨트롤러: 요청에 대응해서 처리할 내용이 있는 곳

- 서비스 처리: 데이터베이스에 접속해서 데이터를 취득하거나 데이터를 가공하는 등 여러 가지 작업을 실행. 개발자가 설계하고 구현. (스프링 MVC와 관계 X)

- 뷰: 화면 표시 처리

-------------------------------------------------------------------
**0529 스프링 Jpa**

공통 인터페이스, JapRepository

Spring Data Map는 JpaRepository 라는 공통 인터페이스를 제공. 기본적인 CRUD와 페이징 등 유용한 기능을 제공한다. 또한 @Repository 어노테이션 생략이 가능하다. 컴포넌트 스캔과 JPA 예외를 스프링 예외로 변환하는 과정을 스프링 데이터 JPA가 자동으로 처리해준다.

JpaRepository<T, ID>	=> T: 엔티티 타입, ID: 식별자 타입

-------------------------------------------------------------------

주요 메서드

JpaRepository가 기본적으로 제공하는 주요 메소드

<S extends T> S save(S): 새로운 엔티티는 저장하고, 이미 있는 엔티티는 병합한다.

delete(T): 엔티티 하나를 삭제한다.

Optional<T> findById(ID): ID로 엔티티 하나를 조회한다.

List<T> findAll(…): 모든 엔티티를 조회한다. 정렬(Sort)이나 페이징(Pageable) 조건을 파라미터로 제공할 수 있다.


Query Creation

Spring Date JPA는 메서드의 이름으로 쿼리를 생성한다.  JpaRepository를 상속한 인터페이스 안에서 규칙에 맞게 메서드를 선언해주면 된다.

--------------------------------------------------------------------------
쿼리 종류/ 이름 규칙

조회: find…By, read…By, query…By, get…By

COUNT: count…By 반환 타입 long

EXISTS: exists…By 반환타입 boolean

삭제: delete…By, remove…By

DISTINCT: findDistinct, findMemberDistinctBy

LIMIT: findFirst3, findFirst, findTop, findTop3

-----------------------------------------------------------
CRUD

Create, Read, Update, Delete의 약어로 데이터베이스와 같은 시스템에서 기본적인 데이터 관리 기능을 의미한다.
